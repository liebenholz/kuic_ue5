#include <iostream>
#include <stdlib.h>

int main() {

	// 컴퓨터는 0,1로만 값을 계산
	// binary, 4개의 비트일 때는 0~15, 16개의 숫자를 표현
	// 0000, 0
	// 0001, 1
	// 0010, 2
	// 0011, 3
	// 0100, 4
	// ...
	// 1111, 15

	// 8개의 비트일 때는 0~255, 256개의 숫자를 표현
	// 0000 0000, 0
	// ...
	// 0001 0000, 16
	// ...
	// 1111 1111, 255

	// 가장 앞 비트는 부호 비트로 빠진다. 
	// 맨 앞의 부호가 1이면 -, 0이면 +
	// 0111 1111 =  127
	// 0000 0001 =	  1
	// 1000 0000 = -128 (128이 아님)

	// 1 + 1 = 2
	// 1 + -1 = 0
	// 0000 0001 (1)
	// 1111 1111 (-1)
	// 0110 0100(100) + 1001 1100(-100) = 0000 0000(0)

	signed char c;		// -128 ~ +127(1바이트)
	unsigned char uc;	// 0 ~ 255(1바이트)
	c = 128;

	// int 자료형
	// x16(16비트 아키텍처): 16비트
	// x86(32비트 아키텍처): 32비트
	// 64x(64비트 아키텍처): 32비트
	// int64 자료형은 64비트

	int a;		// -2,147,483,648 ~ +2,147,483,647(4바이트)
	unsigned int ua; // 0 ~ 4,294,967,295(4바이트)
	short s;	// -32,768 ~ +32,767(2바이트), short int, 작은 정수를 사용하고 싶다.
	long l;		// -2,147,483,648 ~ +2,147,483,647(4바이트), long int, 큰 정수를 사용하고 싶다
	long long ll; // -9,223,372,036,854,775,808 ~ +9,223,372,036,854,775,807(8바이트)

	// float 자료형, 실수, ±3.4x10^-37 ~ ±3.4x10^+38
	// 부동소수점
	// 0(부호부) 0000 0000(지수부) 000 0000 0000 0000 0000 0000(가수부)
	// 21.8125(10101.1101) = 0.218125 * 10^2(0.101011101 * 2^5)
	// 0.218125(0.101011101) 가수부
	// 5(101) 지수부
	// 0 / 0000 0101 / 101 0111 0100 0000 0000 0000

	float f = 0.1f;	// 4바이트
	f = 2.0f;
	f = 2.f;
	// double float 8바이트
	// 얼마나 더 정밀하게 표현할 수 있는가

	// 연산
	int i2 = 0;
	float f2 = 1.0;
	// 캐스팅, 형변환
	i2 = (int)f2;
	f2 = (float)i2;
	f2 = float(i2);
	f2 = (float)(i2+1);
	i2 = (int)f2 + 1;

	// 연산자 + - * / % ++ --
	i2 = 1 + 1;  // 2
	i2 = i2 + 1; // 3
	i2 += 1;     // 4
	i2++;		 // 5

	float div = 10 / 2.0f; // 10 * 0.5f
	int mod = 10 % 3;
	// 실수끼리 나머지 연산 불가. 둘 다 정수여야 함
	// 몇 번째 소수점 자리를 기준으로 연산을 해야하는지 알 수 없음.
	// printf("%f %d", div, mod);

	int add = 0;	// 변수 선언 시 초기화 값을 넣어준다.

	int addL = 0, addR = 0;
	addL = ++add;
	addR = add++;
	// printf("%d %d", addL, addR);
	// add = 2, addL = 1, addR = 1
	// 후치연산은 대입연산자보다 더 뒤에 실행한다.

	bool bResult = 0; // false(0)

	bResult = 10 == 20;	// false
	bResult = 10 == 10; // true
	bResult = 10 != 20;	// true
	bResult = 10 != 10; // false
	bResult = 10 > 20;	// false
	bResult = 10 < 20;	// true
	bResult = 10 >= 20;	// false
	bResult = 10 >= 10; // true
	bResult = 10 <= 20;	// true
	bResult = 10 <= 10; // true

	// 삼항연산자 : 변수이름 = (bool 연산)?(결과가 true일 경우):(결과가 false일 경우)
	int nResult = (10 == 11)? 100: 50;
	// true면 100, false면 50을 저장.
	// 10==11은 false이므로 50을 저장.

	// 문제 아래 time 들어있는 초 값의 분과 시간을 구하여라.
	unsigned int sec = 987654321;

	unsigned int min = sec / 60;
	sec = sec % 60;	// 16460905 min 21 sec

	unsigned int hour = min / 60;
	min = min % 60;	// 174348 hour 25 min

	unsigned int day = hour / 24;
	hour = hour % 24;	// 11431 day 4 hour
	
	printf("%d %d %d %d", day, hour, min, sec);
	// 11431 4 25 21

}